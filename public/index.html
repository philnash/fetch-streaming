<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fetch streaming</title>

    <style>
      * {
        box-sizing: border-box;
      }
      html {
        margin: 0;
        padding: 0;
      }
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
        font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir,
          segoe ui, helvetica neue, helvetica, Cantarell, Ubuntu, roboto, noto,
          arial, sans-serif;
      }
      header {
        width: 100%;
        background: #000;
        padding: 1rem;
        margin-bottom: 2rem;
      }
      header h1 {
        max-width: 960px;
        color: #fff;
        margin: 0 auto;
      }
      main {
        max-width: 960px;
        margin: 0 auto;
        padding: 0 1rem;
      }
      button {
        border: none;
        margin: 0 auto 1rem;
        display: block;
        background-color: #410166;
        border-radius: 6px;
        color: #fff;
        font-weight: bolder;
        font-size: 2rem;
        padding: 1rem 4rem;
      }
      button:hover {
        background-color: #5f1f8c;
      }
      .outputs {
        display: flex;
        gap: 1rem;
      }
      .outputs > div {
        flex: 1;
        border: 3px solid #333;
        border-radius: 6px;
        padding: 1rem;
      }

      .loader {
        width: 15px;
        aspect-ratio: 1;
        border-radius: 50%;
        animation: loading 1s infinite linear;
        margin: auto;
      }
      @keyframes loading {
        0% {
          box-shadow: 20px 0 #000, -20px 0 #0002;
          background: #000;
        }
        25% {
          box-shadow: 20px 0 #000, -20px 0 #0002;
          background: #0002;
        }
        50% {
          box-shadow: 20px 0 #0002, -20px 0 #000;
          background: #0002;
        }
        75% {
          box-shadow: 20px 0 #0002, -20px 0 #000;
          background: #000;
        }
        100% {
          box-shadow: 20px 0 #000, -20px 0 #0002;
          background: #000;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Streaming with fetch</h1>
    </header>
    <main>
      <button id="start">Start</button>
      <div class="outputs">
        <div id="output"></div>
        <div id="stream-output"></div>
      </div>
    </main>

    <script>
      const startButton = document.getElementById("start");
      const output = document.getElementById("output");
      const streamOutput = document.getElementById("stream-output");
      const loaderBase = document.createElement("div");
      loaderBase.classList.add("loader");

      startButton.addEventListener("click", async () => {
        startButton.setAttribute("disabled", "disabled");
        output.innerHTML = "";
        streamOutput.innerHTML = "";

        const loader = loaderBase.cloneNode(false);
        const streamLoader = loaderBase.cloneNode(false);
        output.appendChild(loader);
        streamOutput.append(streamLoader);

        const response = await fetch("/stream");
        if (response.ok) {
          // Clone the response so that we can compare.
          const streamResponse = response.clone();

          // Normal fetch
          response.text().then((text) => {
            output.innerHTML = text;
            loader.parentNode.removeChild(loader);
            startButton.removeAttribute("disabled");
          });

          // Streaming the response through a TextDecoderStream and to a WritableStream.
          const decoderStream = new TextDecoderStream("utf-8");
          const writer = new WritableStream({
            start() {
              streamLoader.parentNode.removeChild(streamLoader);
            },
            write(chunk) {
              streamOutput.innerHTML += chunk;
            },
            close() {
              startButton.removeAttribute("disabled");
            },
            abort(reason) {
              startButton.removeAttribute("disabled");
            },
          });

          streamResponse.body
            .pipeThrough(decoderStream)
            .pipeTo(writer)
            .catch((error) => {
              console.log("Unexpected end of stream");
            });

          // Stream as an async iterable (doesn't work in Safari)
          // const decoder = new TextDecoder();
          // for await (const chunk of streamResponse.body) {
          //   const text = decoder.decode(chunk, { stream: true });
          //   streamOutput.innerHTML += text;
          // }
        }
      });
    </script>
  </body>
</html>
